# =============================================================================
# ENFORCE SPOT INSTANCES - COST CONTROL POLICY
# =============================================================================
# Enforces use of Spot instances for cost savings in appropriate environments

import "tfplan/v2" as tfplan
import "strings"

# Get EC2 instances
ec2_instances = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_instance" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update")
}

# Get Launch Templates
launch_templates = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_launch_template" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update")
}

# Get Auto Scaling Groups
auto_scaling_groups = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_autoscaling_group" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update")
}

# Get Launch Configurations (legacy)
launch_configurations = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_launch_configuration" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update")
}

# Function to determine environment
determine_environment = func(address, tags) {
  if strings.contains(strings.to_lower(address), "dev") {
    return "dev"
  } else if strings.contains(strings.to_lower(address), "staging") {
    return "staging"
  } else if strings.contains(strings.to_lower(address), "prod") {
    return "prod"
  }
  
  if tags is not null {
    if "Environment" in tags {
      env = strings.to_lower(tags.Environment else "")
      if strings.contains(env, "dev") {
        return "dev"
      } else if strings.contains(env, "staging") {
        return "staging"
      } else if strings.contains(env, "prod") {
        return "prod"
      }
    }
  }
  
  return "unknown"
}

# Check if instance type is suitable for Spot
is_spot_suitable = func(instance_type) {
  # Instance types that work well with Spot interruptions
  spot_suitable_families = [
    "t3", "t3a", "t4g",
    "m5", "m5a", "m5n", "m6i", "m6a",
    "c5", "c5a", "c5n", "c6i", "c6a",
    "r5", "r5a", "r5n", "r6i", "r6a",
  ]
  
  for spot_suitable_families as family {
    if strings.has_prefix(instance_type, family + ".") {
      return true
    }
  }
  
  return false
}

# Check if workload should use Spot instances
should_use_spot = func(address, tags, environment) {
  # Check for explicit exemption tags
  if "SpotExempt" in tags or "NoSpot" in tags {
    return false
  }
  
  # Check for critical workloads
  if "Critical" in tags or "Production" in tags {
    critical_value = strings.to_lower(tags.Critical else tags.Production else "")
    if critical_value is "true" or critical_value is "yes" {
      return false
    }
  }
  
  # Development and staging should almost always use Spot
  if environment is "dev" or environment is "staging" {
    return true
  }
  
  # Production workloads may use Spot if fault-tolerant
  if environment is "prod" {
    # Check for fault-tolerant workload indicators
    if "FaultTolerant" in tags or "Stateless" in tags or "WebServer" in tags {
      tolerant_value = strings.to_lower(tags.FaultTolerant else tags.Stateless else tags.WebServer else "")
      if tolerant_value is "true" or tolerant_value is "yes" {
        return true
      }
    }
    
    # Check workload type
    if "WorkloadType" in tags {
      workload = strings.to_lower(tags.WorkloadType else "")
      fault_tolerant_workloads = ["batch", "ci", "testing", "web", "worker", "processing"]
      
      for fault_tolerant_workloads as wl {
        if strings.contains(workload, wl) {
          return true
        }
      }
    }
  }
  
  return false
}

# Calculate potential Spot savings
calculate_spot_savings = func(instance_type) {
  # Typical Spot savings by instance family (approximate)
  savings_by_family = {
    "t3": 60,
    "t3a": 65,
    "t4g": 70,
    "m5": 65,
    "m5a": 70,
    "m5n": 60,
    "m6i": 60,
    "m6a": 70,
    "c5": 65,
    "c5a": 70,
    "c5n": 60,
    "c6i": 60,
    "c6a": 70,
    "r5": 65,
    "r5a": 70,
    "r5n": 60,
    "r6i": 60,
    "r6a": 70,
  }
  
  for savings_by_family as family, savings {
    if strings.has_prefix(instance_type, family + ".") {
      return savings
    }
  }
  
  return 60  # Default savings estimate
}

# Validate EC2 instance Spot usage
validate_ec2_spot_usage = rule {
  all ec2_instances as address, rc {
    instance_type = rc.change.after.instance_type else ""
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    
    # Check if Spot is configured
    instance_market_options = rc.change.after.instance_market_options else {}
    market_type = instance_market_options.market_type else ""
    
    is_spot_configured = market_type is "spot"
    should_spot = should_use_spot(address, tags, environment)
    is_suitable = is_spot_suitable(instance_type)
    
    # Enforce Spot usage for development
    if environment is "dev" and not is_spot_configured and is_suitable {
      savings = calculate_spot_savings(instance_type)
      
      print("POLICY VIOLATION: Development instance should use Spot")
      print("Instance:", address)
      print("Instance type:", instance_type)
      print("Environment:", environment)
      print("Potential savings:", savings, "% (approximately)")
      print("Use 'instance_market_options' block with 'market_type = \"spot\"'")
      print("Example:")
      print("  instance_market_options {")
      print("    market_type = \"spot\"")
      print("    spot_options {")
      print("      max_price = \"auto\"")
      print("    }")
      print("  }")
      false
    } else if should_spot and not is_spot_configured and is_suitable {
      savings = calculate_spot_savings(instance_type)
      
      print("COST CONTROL RECOMMENDATION:")
      print("Instance:", address)
      print("Instance type:", instance_type)
      print("Environment:", environment)
      print("This workload appears suitable for Spot instances")
      print("Potential savings:", savings, "% (approximately)")
      print("Add tags to exempt: SpotExempt=true or Critical=true")
      
      # Warning for staging, advisory for production
      if environment is "staging" {
        print("POLICY VIOLATION: Staging should use Spot for cost optimization")
        false
      } else {
        true  # Advisory for production
      }
    } else {
      true
    }
  }
}

# Validate Launch Template Spot configuration
validate_launch_template_spot = rule {
  all launch_templates as address, rc {
    tags = rc.change.after.tag_specifications else []
    instance_type = rc.change.after.instance_type else ""
    
    # Extract tags from tag_specifications
    resource_tags = {}
    for tags as tag_spec {
      if tag_spec.resource_type is "instance" {
        spec_tags = tag_spec.tags else {}
        for spec_tags as key, value {
          resource_tags[key] = value
        }
      }
    }
    
    environment = determine_environment(address, resource_tags)
    
    # Check if Spot is configured in launch template
    instance_market_options = rc.change.after.instance_market_options else {}
    market_type = instance_market_options.market_type else ""
    
    is_spot_configured = market_type is "spot"
    should_spot = should_use_spot(address, resource_tags, environment)
    is_suitable = is_spot_suitable(instance_type)
    
    if environment is "dev" and not is_spot_configured and is_suitable {
      savings = calculate_spot_savings(instance_type)
      
      print("POLICY VIOLATION: Development launch template should use Spot")
      print("Launch Template:", address)
      print("Instance type:", instance_type)
      print("Environment:", environment)
      print("Potential savings:", savings, "%")
      print("Configure instance_market_options in launch template")
      false
    } else if should_spot and not is_spot_configured and is_suitable and environment is "staging" {
      print("POLICY VIOLATION: Staging launch template should use Spot")
      print("Launch Template:", address)
      print("Instance type:", instance_type)
      print("Environment:", environment)
      false
    } else {
      true
    }
  }
}

# Validate Auto Scaling Group mixed instances policy
validate_asg_mixed_instances = rule {
  all auto_scaling_groups as address, rc {
    tags = rc.change.after.tag else []
    
    # Extract environment from ASG tags
    environment = "unknown"
    for tags as tag {
      if tag.key is "Environment" {
        env = strings.to_lower(tag.value else "")
        if strings.contains(env, "dev") {
          environment = "dev"
        } else if strings.contains(env, "staging") {
          environment = "staging"
        } else if strings.contains(env, "prod") {
          environment = "prod"
        }
      }
    }
    
    # Check for mixed instances policy
    mixed_instances_policy = rc.change.after.mixed_instances_policy else {}
    instances_distribution = mixed_instances_policy.instances_distribution else {}
    
    spot_allocation_strategy = instances_distribution.spot_allocation_strategy else ""
    spot_instance_pools = instances_distribution.spot_instance_pools else 0
    spot_max_price = instances_distribution.spot_max_price else ""
    on_demand_percentage = instances_distribution.on_demand_base_capacity else 0
    
    has_mixed_policy = mixed_instances_policy != {}
    has_spot_config = spot_allocation_strategy != "" or spot_instance_pools > 0
    
    # Enforce mixed instances policy for development and staging
    if (environment is "dev" or environment is "staging") and not has_mixed_policy {
      print("POLICY VIOLATION: Auto Scaling Group should use mixed instances policy")
      print("Auto Scaling Group:", address)
      print("Environment:", environment)
      print("Mixed instances policy enables Spot instance usage")
      print("Potential savings: 60-70% on compute costs")
      print("Example configuration:")
      print("  mixed_instances_policy {")
      print("    instances_distribution {")
      print("      on_demand_base_capacity = 0")
      print("      on_demand_percentage_above_base_capacity = 0")  
      print("      spot_allocation_strategy = \"diversified\"")
      print("    }")
      print("  }")
      false
    } else if has_mixed_policy and not has_spot_config {
      print("COST CONTROL WARNING:")
      print("Auto Scaling Group:", address)
      print("Mixed instances policy configured but no Spot settings")
      print("Enable Spot instances for maximum cost savings")
      true  # Warning only
    } else {
      true
    }
  }
}

# Check Spot instance configuration best practices
validate_spot_configuration = rule {
  all ec2_instances as address, rc {
    instance_market_options = rc.change.after.instance_market_options else {}
    
    if instance_market_options != {} {
      market_type = instance_market_options.market_type else ""
      
      if market_type is "spot" {
        spot_options = instance_market_options.spot_options else {}
        max_price = spot_options.max_price else ""
        
        # Recommend using "auto" for max_price to get maximum savings
        if max_price != "" and max_price != "auto" {
          print("COST CONTROL RECOMMENDATION:")
          print("Spot Instance:", address)
          print("Current max_price:", max_price)
          print("Consider using 'max_price = \"auto\"' for maximum savings")
          print("Auto pricing uses the current Spot price up to On-Demand price")
        }
        
        # Check for proper Spot instance handling tags
        tags = rc.change.after.tags else {}
        
        has_spot_tags = "SpotInstance" in tags or "InterruptionHandling" in tags
        
        if not has_spot_tags {
          print("COST CONTROL RECOMMENDATION:")
          print("Spot Instance:", address)
          print("Add tags to indicate Spot instance handling:")
          print("- SpotInstance=true")
          print("- InterruptionHandling=graceful")
          print("This helps with monitoring and automation")
        }
      }
    }
    
    true  # Advisory only
  }
}

# Validate Spot fleet recommendations for batch workloads
validate_spot_fleet_recommendations = rule {
  all ec2_instances as address, rc {
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    
    # Check for batch or compute-intensive workloads
    workload_type = strings.to_lower(tags.WorkloadType else "")
    
    if strings.contains(workload_type, "batch") or 
       strings.contains(workload_type, "compute") or
       strings.contains(workload_type, "processing") {
      
      print("COST CONTROL RECOMMENDATION:")
      print("Instance:", address)
      print("Workload type:", workload_type)
      print("Environment:", environment)
      print("Consider using EC2 Spot Fleet or Spot Instances for batch workloads")
      print("Batch workloads are ideal for Spot instances due to fault tolerance")
      print("Potential savings: 60-90% compared to On-Demand instances")
      print("Use diversified instance types to reduce interruption risk")
    }
    
    true  # Advisory only
  }
}

# Main rule
main = rule {
  validate_ec2_spot_usage and
  validate_launch_template_spot and
  validate_asg_mixed_instances and
  validate_spot_configuration and
  validate_spot_fleet_recommendations
}

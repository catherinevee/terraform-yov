# =============================================================================
# LIMIT NAT GATEWAYS - COST CONTROL POLICY
# =============================================================================
# Controls NAT Gateway deployment to manage data transfer and hourly costs

import "tfplan/v2" as tfplan
import "strings"

# Get NAT Gateways
nat_gateways = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_nat_gateway" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update")
}

# Get NAT Instances (alternative to NAT Gateways)
nat_instances = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_instance" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update") and
  resource_changes.change.after.tags is not null and
  "NAT" in strings.to_upper(resource_changes.change.after.tags.Name else "")
}

# Get VPC configuration for counting across regions
vpcs = filter tfplan.resource_changes as _, resource_changes {
  resource_changes.type is "aws_vpc" and
  resource_changes.mode is "managed" and
  (resource_changes.change.actions contains "create" or
   resource_changes.change.actions contains "update")
}

# Function to determine environment
determine_environment = func(address, tags) {
  if strings.contains(strings.to_lower(address), "dev") {
    return "dev"
  } else if strings.contains(strings.to_lower(address), "staging") {
    return "staging"
  } else if strings.contains(strings.to_lower(address), "prod") {
    return "prod"
  }
  
  if tags is not null {
    if "Environment" in tags {
      env = strings.to_lower(tags.Environment else "")
      if strings.contains(env, "dev") {
        return "dev"
      } else if strings.contains(env, "staging") {
        return "staging"
      } else if strings.contains(env, "prod") {
        return "prod"
      }
    }
  }
  
  return "unknown"
}

# Function to extract region from address
extract_region = func(address) {
  # Try to extract region from resource address
  if strings.contains(address, "us-east-1") {
    return "us-east-1"
  } else if strings.contains(address, "us-west-2") {
    return "us-west-2"
  } else if strings.contains(address, "eu-west-1") {
    return "eu-west-1"
  } else if strings.contains(address, "eu-central-1") {
    return "eu-central-1"
  } else if strings.contains(address, "ap-southeast-1") {
    return "ap-southeast-1"
  }
  
  return "unknown"
}

# Count NAT Gateways by environment and region
count_nat_gateways_by_env_region = func() {
  counts = {}
  
  for nat_gateways as address, rc {
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    region = extract_region(address)
    
    key = environment + "_" + region
    
    if key in counts {
      counts[key] += 1
    } else {
      counts[key] = 1
    }
  }
  
  return counts
}

# Validate NAT Gateway limits by environment
validate_nat_gateway_limits = rule {
  counts = count_nat_gateways_by_env_region()
  
  # Define limits by environment
  max_nat_gateways = {
    "dev": 1,      # Single NAT Gateway for development
    "staging": 2,  # Up to 2 for staging (maybe multi-AZ)
    "prod": 3,     # Up to 3 for production (multi-AZ)
    "unknown": 1,  # Conservative default
  }
  
  all counts as env_region, count {
    parts = strings.split(env_region, "_")
    environment = parts[0]
    region = parts[1]
    
    max_allowed = max_nat_gateways[environment]
    
    if count > max_allowed {
      print("POLICY VIOLATION: Too many NAT Gateways")
      print("Environment:", environment)
      print("Region:", region)
      print("NAT Gateways being created:", count)
      print("Maximum allowed:", max_allowed)
      print("NAT Gateway costs: $32.85/month + $0.045/GB data transfer")
      print("Consider consolidating or using NAT instances for development")
      false
    } else {
      true
    }
  }
}

# Validate NAT Gateway placement and cost optimization
validate_nat_gateway_optimization = rule {
  all nat_gateways as address, rc {
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    
    # Check for cost optimization tags
    has_cost_tags = "CostOptimized" in tags or "Purpose" in tags
    
    # Development environment specific checks
    if environment is "dev" {
      # Recommend NAT instances for development
      print("COST CONTROL RECOMMENDATION:")
      print("NAT Gateway:", address)
      print("Environment: Development")
      print("Consider using a NAT instance instead of NAT Gateway for development")
      print("NAT Instance savings: ~$25-30/month (t3.nano costs ~$3.50/month)")
      print("NAT Gateway cost: $32.85/month + data transfer charges")
      print("Set tag 'CostOptimized=nat-instance' if NAT Gateway is required")
      
      if not has_cost_tags {
        print("Add 'Purpose' tag to justify NAT Gateway usage in development")
      }
    }
    
    # Check for single AZ in production (cost optimization vs availability)
    if environment is "prod" {
      print("COST CONTROL ADVISORY:")
      print("NAT Gateway:", address)
      print("Environment: Production")
      print("Ensure NAT Gateway placement aligns with availability requirements")
      print("Single NAT Gateway: $32.85/month")
      print("Multi-AZ NAT Gateways: $32.85/month per AZ + cross-AZ data charges")
      print("Balance cost vs availability based on business requirements")
    }
    
    true  # Advisory only
  }
}

# Validate against NAT instance alternatives
validate_nat_instance_recommendations = rule {
  all nat_instances as address, rc {
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    instance_type = rc.change.after.instance_type else ""
    
    # Validate NAT instance sizing
    cost_effective_types = [
      "t3.nano",
      "t3.micro", 
      "t3.small",
      "t4g.nano",
      "t4g.micro",
      "t4g.small",
    ]
    
    if instance_type not in cost_effective_types {
      print("COST CONTROL WARNING:")
      print("NAT Instance:", address)
      print("Instance type:", instance_type)
      print("Consider using smaller instance types for NAT functionality")
      print("Recommended cost-effective types:", cost_effective_types)
      print("NAT functionality typically doesn't require large instances")
    }
    
    # Recommend Spot instances for development NAT instances
    if environment is "dev" {
      spot_price = rc.change.after.spot_price else ""
      
      if spot_price is "" {
        print("COST CONTROL RECOMMENDATION:")
        print("NAT Instance:", address)
        print("Environment: Development")
        print("Consider using Spot instances for development NAT")
        print("Spot instances can provide 60-70% cost savings")
        print("Set 'spot_price' to enable Spot instance pricing")
      }
    }
    
    true  # Advisory only
  }
}

# Check for unnecessary NAT Gateways
validate_nat_gateway_necessity = rule {
  all nat_gateways as address, rc {
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    
    # Check if there are any resources that actually need NAT
    print("COST CONTROL VERIFICATION:")
    print("NAT Gateway:", address)
    print("Environment:", environment)
    print("Verify that private subnet resources require internet access")
    print("Common uses: software updates, API calls, downloading packages")
    print("If no outbound internet access needed, consider removing NAT Gateway")
    print("Monthly savings: $32.85 + data transfer charges")
    
    # Check for development workloads
    if environment is "dev" {
      print("Development alternative: Use public subnets with security groups")
      print("Or use Systems Manager Session Manager for instance access")
      print("This eliminates the need for NAT Gateway in development")
    }
    
    true  # Advisory only
  }
}

# Validate connectivity type (for potential cost savings)
validate_connectivity_type = rule {
  all nat_gateways as address, rc {
    connectivity_type = rc.change.after.connectivity_type else "public"
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    
    # Private NAT Gateways don't incur data transfer charges for internet access
    # but they still have hourly charges
    if connectivity_type is "private" {
      print("COST CONTROL INFO:")
      print("NAT Gateway:", address)
      print("Connectivity type: Private")
      print("Private NAT Gateways still incur hourly charges ($32.85/month)")
      print("They save on internet data transfer but not local data transfer")
      print("Ensure this configuration meets your connectivity requirements")
    }
    
    true  # Informational only
  }
}

# Check for data transfer optimization opportunities
validate_data_transfer_optimization = rule {
  all nat_gateways as address, rc {
    tags = rc.change.after.tags else {}
    environment = determine_environment(address, tags)
    
    print("COST CONTROL TIP:")
    print("NAT Gateway:", address)
    print("Data transfer costs: $0.045/GB")
    print("Optimization strategies:")
    print("1. Use CloudFront for static content delivery")
    print("2. Cache frequently accessed data locally")
    print("3. Use VPC endpoints for AWS services (S3, DynamoDB, etc.)")
    print("4. Compress data transfers when possible")
    print("5. Monitor data transfer patterns with VPC Flow Logs")
    
    if environment is "prod" {
      print("6. Consider Direct Connect for high-volume data transfer")
    }
    
    true  # Advisory only
  }
}

# Main rule
main = rule {
  validate_nat_gateway_limits and
  validate_nat_gateway_optimization and
  validate_nat_instance_recommendations and
  validate_nat_gateway_necessity and
  validate_connectivity_type and
  validate_data_transfer_optimization
}
